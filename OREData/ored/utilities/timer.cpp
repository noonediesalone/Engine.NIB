/*
 Copyright (C) 2024 Quaternion Risk Management Ltd
 All rights reserved.

 This file is part of ORE, a free-software/open-source library
 for transparent pricing and risk analysis - http://opensourcerisk.org

 ORE is free software: you can redistribute it and/or modify it
 under the terms of the Modified BSD License.  You should have received a
 copy of the license along with this program.
 The license is also available online at <http://opensourcerisk.org>

 This program is distributed on the basis that it will form a useful
 contribution to risk analytics and model standardisation, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE. See the license for more details.
*/

/*! \file ored/data/timer.cpp
    \brief Utility function for recording times.
    \ingroup
*/

#include <boost/none.hpp>
#include <ored/utilities/log.hpp>
#include <ored/utilities/timer.hpp>
#include <ql/errors.hpp>

namespace ore {
namespace data {

using boost::timer::cpu_timer;
using std::map;
using std::string;
using std::vector;

void Timer::start(const string& key) {
    if (runningTimers_.find(key) != runningTimers_.end()) {
        StructuredLoggingErrorMessage("Cannot start timer '" + key + "', it already exists.").log();
        return;
    }
    runningTimers_[key] = boost::timer::cpu_timer();
}

boost::optional<cpu_timer> Timer::stop(const string& key, bool returnTimer) {
    boost::optional<cpu_timer> timer = boost::none;
    if (runningTimers_.find(key) == runningTimers_.end()) {
        StructuredLoggingErrorMessage("Cannot stop timer '" + key + "', it does not exist.").log();
        return timer;
    }
    
    runningTimers_[key].stop();

    // Save time stats
    stats_[key].count++;
    auto elapsedTime = runningTimers_[key].elapsed().wall;
    stats_[key].totalTime += elapsedTime;
    stats_[key].maxTime = std::max(stats_[key].maxTime, elapsedTime);
    stats_[key].minTime = std::min(stats_[key].minTime, elapsedTime);

    // Return pointer to timer
    if (returnTimer)
        timer = runningTimers_[key];

    // Remove timer from internal map
    runningTimers_.erase(key);

    return timer;
}

void Timer::addTime(const Timer& timer) {
    for (const auto& [key, stats] : timer.stats()) {
        if (stats_.find(key) != stats_.end()) {
            stats_[key].add(stats);
        } else {
            stats_[key] = stats;
        }
    }
}

void Timer::addTimer(const string& key, const Timer& timer) {
    if (timers_.find(key) != timers_.end()) {
        timers_[key].addTime(timer);
    } else {
        timers_[key] = timer;
    }
}

map<vector<string>, Timer::Statistics> Timer::getTimes() const {
    map<vector<string>, Statistics> times;

    // Insert times generated by this timer
    for (const auto& stat : stats_)
        times.insert({{stat.first}, stat.second});

    // Insert other times added from other sources
    for (const auto& timer : timers_) {
        for (const auto& subTimes : timer.second.getTimes()) {
            // Combine keys
            vector<string> fullKey({timer.first});
            fullKey.insert(std::end(fullKey), std::begin(subTimes.first), std::end(subTimes.first));

            times[fullKey] = subTimes.second;
        }
    }

    return times;
}

} // namespace data
} // namespace ore
