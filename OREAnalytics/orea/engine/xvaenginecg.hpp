/*
 Copyright (C) 2023 Quaternion Risk Management Ltd
 All rights reserved.

 This file is part of ORE, a free-software/open-source library
 for transparent pricing and risk analysis - http://opensourcerisk.org

 ORE is free software: you can redistribute it and/or modify it
 under the terms of the Modified BSD License.  You should have received a
 copy of the license along with this program.
 The license is also available online at <http://opensourcerisk.org>

 This program is distributed on the basis that it will form a useful
 contribution to risk analytics and model standardisation, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE. See the license for more details.
*/

/*! \file orea/engine/xvaenginecg.hpp
    \brief xva engine using cg infrastructure
    \ingroup engine
*/

#pragma once

#include <orea/cube/sensicube.hpp>
#include <orea/scenario/scenariogeneratordata.hpp>
#include <orea/scenario/scenariosimmarketparameters.hpp>
#include <orea/scenario/sensitivityscenariodata.hpp>
#include <orea/scenario/sensitivityscenariogenerator.hpp>

#include <ored/configuration/curveconfigurations.hpp>
#include <ored/marketdata/loader.hpp>
#include <ored/model/crossassetmodelbuilder.hpp>
#include <ored/portfolio/portfolio.hpp>
#include <ored/report/inmemoryreport.hpp>
#include <ored/scripting/models/gaussiancamcg.hpp>
#include <ored/utilities/progressbar.hpp>

#include <ored/marketdata/todaysmarket.hpp>

#include <qle/ad/computationgraph.hpp>
#include <qle/ad/external_randomvariable_ops.hpp>
#include <qle/math/computeenvironment.hpp>

#include <ql/types.hpp>

namespace ore {
namespace analytics {

class XvaEngineCG : public ore::data::ProgressReporter {
public:
    enum class Mode { Disabled, CubeGeneration, Full };

    ~XvaEngineCG();
    XvaEngineCG(const Mode mode, const Size nThreads, const Date& asof,
                const QuantLib::ext::shared_ptr<ore::data::Loader>& loader,
                const QuantLib::ext::shared_ptr<ore::data::CurveConfigurations>& curveConfigs,
                const QuantLib::ext::shared_ptr<ore::data::TodaysMarketParameters>& todaysMarketParams,
                const QuantLib::ext::shared_ptr<ore::analytics::ScenarioSimMarketParameters>& simMarketData,
                const QuantLib::ext::shared_ptr<ore::data::EngineData>& engineData,
                const QuantLib::ext::shared_ptr<ore::analytics::CrossAssetModelData>& crossAssetModelData,
                const QuantLib::ext::shared_ptr<ore::analytics::ScenarioGeneratorData>& scenarioGeneratorData,
                const QuantLib::ext::shared_ptr<ore::data::Portfolio>& portfolio,
                const string& marketConfiguration = Market::defaultConfiguration,
                const string& marketConfigurationInCcy = Market::inCcyConfiguration,
                const QuantLib::ext::shared_ptr<ore::analytics::SensitivityScenarioData>& sensitivityData = nullptr,
                const QuantLib::ext::shared_ptr<ReferenceDataManager>& referenceData = nullptr,
                const IborFallbackConfig& iborFallbackConfig = IborFallbackConfig::defaultConfig(),
                const bool bumpCvaSensis = false, const bool enableDynamicIM = false, const Size dynamicIMStepSize = 1,
                const Size regressionOrder = 4, const double regressionVarianceCutoff = Null<Real>(),
                const bool tradeLevelBreakDown = true, const bool useRedBlocks = true,
                const bool useExternalComputeDevice = false, const bool externalDeviceCompatibilityMode = false,
                const bool useDoublePrecisionForExternalCalculation = false,
                const std::string& externalComputeDevice = std::string(), const bool usePythonIntegration = false,
                const bool continueOnCalibrationError = true, const bool continueOnError = true,
                const std::string& context = "xva engine cg");

    // if nullptr, no offset scenario to be applied, otherwise the base market will be shifted by that scenario
    void setOffsetScenario(const QuantLib::ext::shared_ptr<Scenario>& offsetScenario);

    // set asd - if not nullptr the container will be populated when running the engine
    void setAggregationScenarioData(const QuantLib::ext::shared_ptr<ore::analytics::AggregationScenarioData>& asd);

    // set npv output cube - if not nullptr, the cube will be populated when running the engine
    void setNpvOutputCube(const QuantLib::ext::shared_ptr<ore::analytics::NPVCube>& npvOutputCube);

    // set dynamic IM output cube - if not nullptr and dynamicIM is true, it will be populated with netting set IM
    void setDynamicIMOutputCube(const QuantLib::ext::shared_ptr<ore::analytics::NPVCube>& dynamicIMOutputCube);

    // run the engine, this is required before populateNpvCube() is called or reports are retrieved
    void run();

    // retrieve reports generated by the engine in mode Full (otherwise nullptr is returned)
    QuantLib::ext::shared_ptr<InMemoryReport> exposureReport() const { return epeReport_; }
    QuantLib::ext::shared_ptr<InMemoryReport> sensiReport() const { return sensiReport_; }

private:
    void buildT0Market();
    void buildSsm();
    void buildCam();
    void buildPortfolio();
    void buildCgPartB();
    void buildCgPartC();
    void buildCgPP();
    void buildAsdNodes();
    void getExternalContext();
    void setupValueContainers();
    void doForwardEvaluation();
    void populateAsd();
    void populateNpvOutputCube();
    void populateDynamicIMOutputCube();
    void generateXvaReports();
    void calculateDynamicIM();
    void calculateSensitivities();
    void generateSensiReports();
    void cleanUpAfterCalcs();
    void outputGraphStats();
    void outputTimings();

    void finalizeExternalCalculation();
    void populateRandomVariates(std::vector<RandomVariable>& values,
                                std::vector<ExternalRandomVariable>& valuesExternal) const;
    void populateConstants(std::vector<RandomVariable>& values,
                           std::vector<ExternalRandomVariable>& valuesExternal) const;
    void populateModelParameters(const std::vector<std::pair<std::size_t, double>>& modelParameters,
                                 std::vector<RandomVariable>& values,
                                 std::vector<ExternalRandomVariable>& valuesExternal) const;

    std::pair<std::set<std::size_t>, std::set<std::set<std::size_t>>>
    getRegressors(const std::size_t dateIndex, const Date& obsDate, const std::set<std::size_t>& tradeIds);
    std::pair<std::size_t, std::size_t> createPortfolioExposureNode(const std::size_t dateIndex,
                                                                    const bool isValuationDate);
    std::size_t createTradeExposureNode(const std::size_t dateIndex, const std::size_t tradeIndex,
                                        const bool isValuationDate);
    std::size_t getAmcNpvIndexForValuationDate(const std::size_t i) const;
    std::size_t getAmcNpvIndexForCloseOutDate(const std::size_t i) const;

    // set via additional methods

    QuantLib::ext::shared_ptr<ore::analytics::AggregationScenarioData> asd_;
    QuantLib::ext::shared_ptr<ore::analytics::Scenario> offsetScenario_;
    QuantLib::ext::shared_ptr<ore::analytics::NPVCube> npvOutputCube_;
    QuantLib::ext::shared_ptr<ore::analytics::NPVCube> dynamicIMOutputCube_;

    // input parameters from constructor

    Mode mode_;
    Date asof_;
    QuantLib::ext::shared_ptr<ore::data::Loader> loader_;
    QuantLib::ext::shared_ptr<ore::data::CurveConfigurations> curveConfigs_;
    QuantLib::ext::shared_ptr<ore::data::TodaysMarketParameters> todaysMarketParams_;
    QuantLib::ext::shared_ptr<ore::analytics::ScenarioSimMarketParameters> simMarketData_;
    QuantLib::ext::shared_ptr<ore::data::EngineData> engineData_;
    QuantLib::ext::shared_ptr<ore::analytics::CrossAssetModelData> crossAssetModelData_;
    QuantLib::ext::shared_ptr<ore::analytics::ScenarioGeneratorData> scenarioGeneratorData_;
    QuantLib::ext::shared_ptr<ore::data::Portfolio> portfolio_;
    std::string marketConfiguration_;
    std::string marketConfigurationInCcy_;
    QuantLib::ext::shared_ptr<ore::analytics::SensitivityScenarioData> sensitivityData_;
    QuantLib::ext::shared_ptr<ReferenceDataManager> referenceData_;
    IborFallbackConfig iborFallbackConfig_;
    bool bumpCvaSensis_;
    bool enableDynamicIM_;
    Size dynamicIMStepSize_;
    Size regressionOrder_;
    Real regressionVarianceCutoff_;
    bool tradeLevelBreakDown_;
    bool useRedBlocks_;
    bool useExternalComputeDevice_;
    bool externalDeviceCompatibilityMode_;
    bool useDoublePrecisionForExternalCalculation_;
    std::string externalComputeDevice_;
    bool usePythonIntegration_;
    bool continueOnCalibrationError_;
    bool continueOnError_;
    std::string context_;

    // artefacts produced during lifetime of engine instance

    bool firstRun_ = true;

    QuantLib::ext::shared_ptr<ore::data::Market> initMarket_;
    QuantLib::ext::shared_ptr<ore::analytics::ScenarioSimMarket> simMarket_;
    QuantLib::ObservableValue<QuantLib::ext::shared_ptr<ore::data::Market>> simMarketObs_;
    QuantLib::ext::shared_ptr<SensitivityScenarioGenerator> sensiScenarioGenerator_;
    QuantLib::ext::shared_ptr<CrossAssetModelBuilder> camBuilder_;
    QuantLib::ext::shared_ptr<GaussianCamCG> model_;

    std::set<Date> simulationDates_;
    std::vector<Date> stickyCloseOutDates_;
    std::vector<Date> valuationDates_;
    std::vector<Date> closeOutDates_;

    std::vector<std::pair<std::size_t, double>> baseModelParams_;
    std::vector<RandomVariableOpNodeRequirements> opNodeRequirements_;
    std::vector<RandomVariableOp> ops_;
    std::vector<RandomVariableGrad> grads_;
    std::vector<ExternalRandomVariableOp> opsExternal_;
    std::vector<ExternalRandomVariableGrad> gradsExternal_;
    std::size_t externalCalculationId_ = 0;
    QuantExt::ComputeContext::Settings externalComputeDeviceSettings_;

    // trade level exposure, per valuation resp. close-out date, as path values (no conditional expectation)
    std::vector<std::vector<std::size_t>> amcNpvNodes_;         // valuation date npv nodes
    std::vector<std::vector<std::size_t>> amcNpvCloseOutNodes_; // includes time zero npv

    // trade level exposure, as conditional expectation
    std::vector<std::vector<std::size_t>> tradeExposureNodes_;                    // includes time zero npv
    std::vector<std::vector<std::size_t>> tradeExposureCloseOutNodes_;            // includes time zero npv
    std::vector<std::set<std::string>> tradeRelevantCurrencies_;                  // relevant ccys per trade
    std::vector<bool> tradeHasVega_;                                              // vega flag per trade

    // portfolio exposure, per valuation resp. close-out date, as path values and conditional expectation
    std::vector<std::size_t> pfExposureNodesPathwise_, pfExposureNodes_;
    std::vector<std::size_t> pfExposureCloseOutNodes_;

    // only for dynamicIM:
    // - parameter groups filtering on sensis
    // - for each parameter group the portfolio exposure, per valuation date, inflated and pathwise
    std::set<std::set<ModelCG::ModelParameter>> dynamicIMModelParameterGroups_;
    std::vector<std::vector<std::size_t>> pfExposureNodesForDynamicIMByParameterGroup_;

    // dynamic im per netting set
    std::map<std::string, std::vector<RandomVariable>> dynamicIM_;

    // asd nodes
    std::vector<std::size_t> asdNumeraire_;
    std::vector<std::vector<std::size_t>> asdFx_, asdIndex_;

    // nodes to keep in calculation graph algorightms
    std::vector<bool> keepNodes_;

    // the cva node from the cg-pp
    std::size_t cvaNode_ = QuantExt::ComputationGraph::nan;

    /* regressor groups per portfolio exposure node, the groups are set on
       - pfExposureNodesPathwise
       - pfExposureNodes
       - pfExposureCloseOutNodes */
    std::map<std::size_t, std::set<std::set<std::size_t>>> pfRegressorPosGroups_;

    std::vector<RandomVariable> values_;
    std::vector<RandomVariable> xvaDerivatives_;
    std::vector<RandomVariable> dynamicIMDerivatives_;
    std::vector<ExternalRandomVariable> valuesExternal_;

    std::vector<std::size_t> externalOutputNodes_;

    QuantLib::ext::shared_ptr<DoublePrecisionSensiCube> sensiResultCube_;

    boost::timer::nanosecond_type timing_t0_ = 0, timing_ssm_ = 0, timing_parta_ = 0, timing_pf_ = 0, timing_partb_ = 0,
                                  timing_partc_ = 0, timing_partd_ = 0, timing_popparam_ = 0, timing_poprv_ = 0,
                                  timing_fwd_ = 0, timing_dynamicIM_ = 0, timing_bwd_ = 0, timing_sensi_ = 0,
                                  timing_asd_ = 0, timing_outcube_ = 0, timing_imcube_ = 0, timing_total_ = 0;
    std::size_t numberOfRedNodes_, rvMemMax_;

    // output reports

    QuantLib::ext::shared_ptr<InMemoryReport> epeReport_, sensiReport_;
};

XvaEngineCG::Mode parseXvaEngineCgMode(const std::string& s);
std::ostream& operator<<(std::ostream& os, XvaEngineCG::Mode m);

} // namespace analytics
} // namespace ore
